#!/usr/bin/env python3
import time
import os
import pickle
import json

from http.server import HTTPServer, BaseHTTPRequestHandler
from hashlib import sha1

from feedgen.feed import FeedGenerator

import youtube


class PodcastUpdater:
    instance = None

    def get_instance():
        if PodcastUpdater.instance:
            return PodcastUpdater.instance
        else:
            PodcastUpdater.instance = PodcastUpdater()
            return PodcastUpdater.instance

    def __init__(self):
        self.podcasts = config["podcasts"]

        self.feeds_file = "feeds.save"
        if os.path.isfile(self.feeds_file):
            with open(self.feeds_file, "rb") as feeds:
                self.feeds = pickle.load(feeds)
        else:
            self.feeds = {}

    def get_xml(self, channel, playlist):
        channel = channel.replace('_', ' ')
        playlist = playlist.replace('_', ' ')

        for podcast in self.podcasts:
            if podcast["username"] == channel:
                break
        else:
            return None

        if playlist not in podcast["playlists"]:
            return None

        xml = self.update_podcast(channel, playlist)

        if xml:
            return open(xml).read()

    def update_podcast(self, channel, playlist):
        feed_id = sha1(bytes("%s %s" % (channel, playlist), "UTF-8")).hexdigest()
        yt_channel = yt.get_channel(channel)[0]
        yt_playlists = yt.get_playlists(yt_channel, 50)

        for yt_playlist in yt_playlists:
            if yt_playlist["snippet"]["title"] == playlist:
                break
        else:
            return None

        if feed_id in self.feeds:
            feed = self.feeds[feed_id]
        else:
            feed = self.add_feed(feed_id, yt_playlist)

        if feed.last_updated < time.time() - 600:
            self.populate_feed(feed, feed_id, yt_playlist)

            feed_file = "%s.xml" % (feed_id)
            self.feeds[feed_id].rss_file(feed_file)

            with open(self.feeds_file, "wb") as feed:
                pickle.dump(self.feeds, feed)

        return "%s.xml" % (feed_id)

    def add_feed(self, feed_id, yt_playlist):
        feed = FeedGenerator()
        feed.load_extension("podcast")
        feed.id(feed_id)
        feed.title(yt_playlist["snippet"]["title"])
        feed.author({"name": yt_playlist["snippet"]["channelTitle"]})
        feed.description(yt_playlist["snippet"]["description"])
        feed.logo(yt_playlist["snippet"]["thumbnails"]["standard"]["url"])
        feed.link(href="https://www.youtube.com/playlist?list=%s" % (yt_playlist["id"]))
        feed.rss_str(pretty=True)
        feed.last_updated = 0
        self.feeds[feed_id] = feed
        return feed

    def populate_feed(self, feed, feed_id, yt_playlist, max_results=5):
        videos = yt.get_playlist_items(yt_playlist, max_results)
        downloader = youtube.Downloader.get_instance("vorbis", "downloads", "192.168.178.100")

        entries = feed.entry()
        for video in videos:
            video_id = sha1(bytes(video["id"], "UTF-8")).hexdigest()
            for entry in entries:
                if entry.id() == video_id:
                    break
            else:
                url, size, mime = downloader.download(video, video_id, feed_id)
                feed_entry = feed.add_entry()
                feed_entry.id(video_id)
                feed_entry.guid(video_id)
                feed_entry.title(video["snippet"]["title"])
                feed_entry.description(video["snippet"]["description"])
                feed_entry.published(video["snippet"]["publishedAt"])
                feed_entry.enclosure(url, size, mime)

        feed.last_updated = time.time()


class PodcastFeeder(BaseHTTPRequestHandler):
    def do_GET(self):
        updater = PodcastUpdater.get_instance()
        path = self.path.split('/')

        if len(path) == 3:
            channel = path[1]
            playlist = path[2]
        else:
            return self.return_error(404)

        xml = updater.get_xml(channel, playlist)

        if not xml:
            return self.return_error(404)
        else:
            self.send_response(200)
            self.send_header("Content-type", "text/xml")
            self.end_headers()
            self.wfile.write(bytes(xml, 'UTF-8'))

    def return_error(self, code):
        self.send_response(code)
        self.send_header("Content-type", "text/html")
        self.end_headers()

        reponse = "<body>Error: %s</body>" % (code)
        self.wfile.write(bytes(reponse, 'UTF-8'))


def main():
    try:
        server = HTTPServer(("", 8888), PodcastFeeder)
        server.serve_forever()
    except KeyboardInterrupt:
        server.socket.close()

if __name__ == "__main__":
    config = json.load(open("youtube-podcaster.json"))
    yt = youtube.Youtube(config["youtube"]["api-key"])
    main()

#  vim: set ts=8 sw=4 tw=0 et :
